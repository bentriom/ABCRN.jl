var documenterSearchIndex = {"docs":
[{"location":"api/trajectory.html#Trajectory-related-methods","page":"Trajectory","title":"Trajectory related methods","text":"","category":"section"},{"location":"api/trajectory.html","page":"Trajectory","title":"Trajectory","text":"Modules = [ABCRN]\nPages   = [\"src/trajectory.jl\"]","category":"page"},{"location":"api/trajectory.html#ABCRN.dist_lp-Tuple{AbstractTrajectory, AbstractTrajectory, Symbol}","page":"Trajectory","title":"ABCRN.dist_lp","text":"dist_lp(σ1, σ2, var; verbose, p, str_stat)   \n\nFunction that computes Lp distance between two trajectories of any dimension. It computes Lp distances for each observed variable (contained in get_obs_var(σ)). and then apply a statistic on these distances. Requires get_obs_var(σ1) == get_obs_var(σ2), it is verified if they are simulated from the same model. ...\n\nArguments\n\nσ1::AbstractTrajectory is the first trajectory. σ2 is the second.\nvar::Symbol is an observed variable. Have to be contained in get_obs_var(σ1) and get_obs_var(σ2).\nverbose::Bool If true, launch a verbose execution of the computation. \n\n...\n\n\n\n\n\n","category":"method"},{"location":"api/trajectory.html#ABCRN.dist_lp-Tuple{AbstractTrajectory, AbstractTrajectory}","page":"Trajectory","title":"ABCRN.dist_lp","text":"dist_lp(σ1, σ2; verbose, p, str_stat)   \n\nFunction that computes Lp distance between two trajectories of any dimension. It computes Lp distances for each observed variable (contained in get_obs_var(σ)). and then apply a statistic on these distances. Requires get_obs_var(σ1) == get_obs_var(σ2), it is verified if they are simulated from the same model. ...\n\nArguments\n\nσ1::AbstractTrajectory is the first trajectory. σ2 is the second.\nverbose::Bool If true, launch a verbose execution of the computation. \nstr_stat::String allows to set the statistic to apply on the distances computed  of the trajectories. \n\nOnly \"mean\" is available for now on. ...\n\n\n\n\n\n","category":"method"},{"location":"api/trajectory.html#ABCRN.dist_lp-Tuple{Vector{var\"#s18\"} where var\"#s18\"<:AbstractTrajectory, Vector{var\"#s19\"} where var\"#s19\"<:AbstractTrajectory}","page":"Trajectory","title":"ABCRN.dist_lp","text":"dist_lp(l_σ1, l_σ2; verbose, p, str_stat_list, str_stat_trajectory) \n\nFunction that computes Lp distance between two set of any dimensional trajectories. ...\n\nArguments\n\nl_σ1::Vector{AbstractTrajectory} is the first set of trajectories. l_σ2 is the second.\nverbose::Bool If true, launch a verbose execution of the computation. \nstr_stat_list::String allows to set the statistic to apply on the distances of the trajectories. \n\nIt is salso called linkage function in clustering field. Only \"mean\" is available for now on. ...\n\n\n\n\n\n","category":"method"},{"location":"api/abc.html#Approximate-Bayesian-Computation-related-methods","page":"Approximate Bayesian Computation","title":"Approximate Bayesian Computation related methods","text":"","category":"section"},{"location":"api/abc.html","page":"Approximate Bayesian Computation","title":"Approximate Bayesian Computation","text":"Modules = [ABCRN]\nPages   = [\"algorithms/abc_smc.jl\", \"algorithms/abc_model_choice.jl\"]","category":"page"},{"location":"api/abc.html#ABCRN.abc_smc-Tuple{ParametricModel, AbstractVector{T} where T, Function}","page":"Approximate Bayesian Computation","title":"ABCRN.abc_smc","text":"abc_smc(pm::ParametricModel, l_obs, func_dist; nbr_particles, alpha, kernel_type, NT\n        duration_time, bound_sim, sym_var_aut, verbose)\n\nRun the ABC-SMC algorithm with the pm parametric model. \n\nfunc_dist(l_sim, l_obs) is the distance function between simulations and observation,  it corresponds to rho(eta(y_sim) eta(y_exp)). l_obs::Vector{<:T2} is a collection of observations. dist must have a signature of the form func_dist(l_sim::Vector{T1}, l_obs::Vector{T2}).\n\nIf pm is defined on a ContinuousTimeModel, then T1 should verify T1 <: Trajectory.\n\n!!! Distance function and distributed ABC     If you use abc_smc with multiple workers, dist has to be defined      on every workers by using @everywhere.\n\n\n\n\n\n","category":"method"},{"location":"api/abc.html#ABCRN.abc_model_choice_dataset-Tuple{Vector{var\"#s109\"} where var\"#s109\"<:Union{Model, ParametricModel}, Any, Function, Function, Int64, Int64}","page":"Approximate Bayesian Computation","title":"ABCRN.abc_model_choice_dataset","text":"abc_model_choice_dataset(models,\n                         summary_stats_observations,\n                         summary_stats_func::Function, distance_func::Function,\n                         k::Int, N_ref::Int; dir_results::Union{Nothing,String} = nothing)\n\nCreates a reference table for ABC model choice with discrete uniform prior distribution over the models.\n\n\n\n\n\n","category":"method"},{"location":"api/abc.html#ABCRN.abc_model_choice_dataset-Tuple{Vector{var\"#s109\"} where var\"#s109\"<:Union{Model, ParametricModel}, Distribution{Distributions.Univariate, Distributions.Discrete}, Any, Function, Function, Int64, Int64}","page":"Approximate Bayesian Computation","title":"ABCRN.abc_model_choice_dataset","text":"abc_model_choice_dataset(models, models_prior,\n                         summary_stats_observations,\n                         summary_stats_func::Function, distance_func::Function,\n                         k::Int, N_ref::Int; dir_results::Union{Nothing,String} = nothing)\n\nCreates a reference table for ABC model choice.\n\nThe mandatory arguments are:\n\nmodels is a list of objects inherited from Model or ParametricModel,\nmodels_prior: the prior over the models (by default: discrete uniform distribution)\nsummary_stats_observations are the summary statitics of the observations,\nsummary_stats_func::Function: the function that computes the summary statistics over a model simulation,\ndistance_func: the distance function over the summary statistics space,\nN_ref: the number of samples in the reference table,\nk: the k nearest samples from the observations to keep in the reference table (k < N_ref).\n\nThe result is a AbcModelChoiceDataset with fields:\n\nsummary_stats_matrix: the (Nstats, Nref) features matrix. Accessible via .X.\nsummary_stats_observations: the observations used for simulating the dataset.\nmodels_indexes: the labels vector. Accessible via .y.\n\nIf specified, dir_results is the directory where the summary statistics matrix and associated models are stored (CSV).\n\n\n\n\n\n","category":"method"},{"location":"api/abc.html#ABCRN.posterior_proba_model-Tuple{ABCRN.RandomForestABC}","page":"Approximate Bayesian Computation","title":"ABCRN.posterior_proba_model","text":"posterior_proba_model(rf_abc::RandomForestABC)\n\nEstimates the posterior probability of the model P(M = widehatM(s_obs)  s_obs) with the Random Forest ABC method.\n\n\n\n\n\n","category":"method"},{"location":"api/abc.html#ABCRN.rf_abc_model_choice-Tuple{ABCRN.AbcModelChoiceDataset}","page":"Approximate Bayesian Computation","title":"ABCRN.rf_abc_model_choice","text":"rf_abc_model_choice(abc_trainset;\n                    k::Int = N_ref, distance_func::Function = (x,y) -> 1, \n                    hyperparameters_range::Dict)\n\nRun the Random Forest Approximate Bayesian Computation model choice method with an already simulated dataset.\n\nThe mandatory arguments are:\n\nabc_trainset: an already simulated dataset with `abc_model_choice_dataset\n\nThe optional arguments are:\n\nhyperparameters_range: a dict with the hyperparameters range values for the cross validation fit of the    Random Forest (by default: Dict(:n_estimators => [200], :min_samples_leaf => [1], :min_samples_split => [2])).   See scikit-learn documentation of RandomForestClassifier for the hyperparameters name.\n\nThe result is a RandomForestABC object with fields:\n\nreference_table an AbcModelChoiceDataset that corresponds to the reference table of the algorithm, \nclf a random forest classifier (PyObject from scikit-learn),\nsummary_stats_observations are the summary statitics of the observations\nestim_model is the underlying model of the observations inferred with the RF-ABC method.\n\n\n\n\n\n","category":"method"},{"location":"api/abc.html#ABCRN.rf_abc_model_choice-Tuple{Vector{var\"#s109\"} where var\"#s109\"<:Union{Model, ParametricModel}, Any, Function, Int64}","page":"Approximate Bayesian Computation","title":"ABCRN.rf_abc_model_choice","text":"rf_abc_model_choice(models, summary_stats_observations,\n                    summary_stats_func::Function, N_ref::Int;\n                    k::Int = N_ref, distance_func::Function = (x,y) -> 1, \n                    hyperparameters_range::Dict)\n\nRun the Random Forest Approximate Bayesian Computation model choice method.\n\nThe mandatory arguments are:\n\nmodels is a list of objects inherited from Model or ParametricModel,\nsummary_stats_observations are the summary statitics of the observations\nN_ref: the number of samples in the reference table.\nsummary_stats_func::Function: the function that computes the summary statistics over a model simulation.\n\nThe optional arguments are:\n\nmodels_prior: the prior over the models (by default: discrete uniform distribution)\nk: the k nearest samples from the observations to keep in the reference table (by default: k = N_ref)\ndistance_func: the distance function, has to be defined if k < N_ref\nhyperparameters_range: a dict with the hyperparameters range values for the cross validation fit of the    Random Forest (by default: Dict(:n_estimators => [200], :min_samples_leaf => [1], :min_samples_split => [2])).   See scikit-learn documentation of RandomForestClassifier for the hyperparameters name.\n\nThe result is a RandomForestABC object with fields:\n\nreference_table an AbcModelChoiceDataset that corresponds to the reference table of the algorithm, \nclf a random forest classifier (PyObject from scikit-learn),\nsummary_stats_observations are the summary statitics of the observations\nestim_model is the underlying model of the observations inferred with the RF-ABC method.\n\n\n\n\n\n","category":"method"},{"location":"api/model.html#Model-test-related-methods","page":"Model","title":"Model test related methods","text":"","category":"section"},{"location":"api/model.html","page":"Model","title":"Model","text":"Modules = [ABCRN]\nPages   = [\"src/model.jl\"]","category":"page"},{"location":"api/model.html#ABCRN.change_simulation_stop_criteria-Tuple{ContinuousTimeModel, Symbol}","page":"Model","title":"ABCRN.change_simulation_stop_criteria","text":"change_simulation_stop_criteria(m::ContinuousTimeModel, isabsorbing_func::Symbol)\n\nChange the simulation of the model m by adding a stop criteria based on the function named isabsorbing_func::Symbol. isabsorbing_func must have the type signature isabsorbing_func(p::Vector{Float64}, x::Vector{Int}) where p is the parameter vector of the model and x a state (not an observed state) of the model.\n\n\n\n\n\n","category":"method"},{"location":"api/model.html#ABCRN.distribute_mean_value_lha-Tuple{SynchronizedModel, Symbol, Int64}","page":"Model","title":"ABCRN.distribute_mean_value_lha","text":"distribute_mean_value_lha(sm::SynchronizedModel, sym_var::Symbol, nbr_stim::Int)\n\nDistribute over workers the computation of the mean value  of an LHA over nbr_sim simulations of the model.\n\n\n\n\n\n","category":"method"},{"location":"api/model.html#ABCRN.draw!-Tuple{AbstractMatrix{Float64}, ParametricModel}","page":"Model","title":"ABCRN.draw!","text":"draw!(mat_p, pm)\n\nDraw size(mat_p)[2] (number of columns of mat_p) parameters from the prior distribution  defined in pm and stores it in mat_p.\n\n\n\n\n\n","category":"method"},{"location":"api/model.html#ABCRN.draw!-Tuple{AbstractVector{Float64}, ParametricModel}","page":"Model","title":"ABCRN.draw!","text":"draw!(vec_p, pm)\n\nDraw a parameter from the prior distribution defined in pm and stores it in vec_p.\n\n\n\n\n\n","category":"method"},{"location":"api/model.html#ABCRN.draw_model!-Tuple{ParametricModel}","page":"Model","title":"ABCRN.draw_model!","text":"draw_model!(pm::ParametricModel)\n\nDraw a parameter from the prior disitribution defined in pm::ParametricModel and save it in the model contained in pm.\n\n\n\n\n\n","category":"method"},{"location":"api/model.html#ABCRN.prior_pdf!-Tuple{AbstractVector{Float64}, ParametricModel, AbstractMatrix{Float64}}","page":"Model","title":"ABCRN.prior_pdf!","text":"prior_pdf(res_pdf, mat_p, pm)\n\nComputes the density for each column of mat_p of the prior distribution defined in pm. Stores it in res_pdf. (length(vec_res) == size(mat_p)[2])\n\n\n\n\n\n","category":"method"},{"location":"api/model.html#ABCRN.prior_pdf-Tuple{ParametricModel, AbstractVector{Float64}}","page":"Model","title":"ABCRN.prior_pdf","text":"prior_pdf(p_prior, pm)\n\nComputes the density at p_prior of the prior distribution defined in pm.\n\n\n\n\n\n","category":"method"},{"location":"api/model.html#ABCRN.probability_var_value_lha-Tuple{SynchronizedModel, Int64}","page":"Model","title":"ABCRN.probability_var_value_lha","text":"distribute_var_value_lha(sm::SynchronizedModel, nbr_sim::Int, value = 0, sym_var = :d)\n\nCompute the probability that the variable sym_var is equal to value of an LHA over nbr_sim simulations of the model.\n\n\n\n\n\n","category":"method"},{"location":"api/model.html#ABCRN.simulate-Tuple{ParametricModel, AbstractVector{Float64}}","page":"Model","title":"ABCRN.simulate","text":"simulate(pm::ParametricModel, p_prior::AbstractVector{Float64})\n\nSimulates the model contained in the parametric model pm with the p_prior parameters. It simulates the model by taking the parameters contained in get_proba_model(pm).p and replace the 1D parameters pm.params with p_prior.\n\n\n\n\n\n","category":"method"},{"location":"api/model.html#ABCRN.volatile_simulate-Tuple{ParametricModel, AbstractVector{Float64}}","page":"Model","title":"ABCRN.volatile_simulate","text":"volatile_simulate(pm::ParametricModel, p_prior::AbstractVector{Float64})\n\nA volatile version of simulate(pm::ParametricModel, p_prior::AbstractVector{Float64}). The model in pm should be of type SynchronizedModel (typeof(pm.m) <: SynchronizedModel). It returns S::StateLHA, not a trajectory.\n\n\n\n\n\n","category":"method"},{"location":"api/model.html#ABCRN.volatile_simulate-Tuple{SynchronizedModel}","page":"Model","title":"ABCRN.volatile_simulate","text":"volatile_simulate(sm::SynchronizedModel; p, verbose)\n\nSimulates a model synchronized with an automaton but does not store the values of the simulation  in order to improve performance. It returns the last state of the simulation S::StateLHA not a trajectory σ::SynchronizedTrajectory.\n\n\n\n\n\n","category":"method"},{"location":"create_model.html#Create-a-model","page":"Create a model","title":"Create a model","text":"","category":"section"},{"location":"create_model.html","page":"Create a model","title":"Create a model","text":"The package offers different ways to create models based on CRNs.","category":"page"},{"location":"create_model.html#Load-a-pre-written-model","page":"Create a model","title":"Load a pre-written model","text":"","category":"section"},{"location":"create_model.html","page":"Create a model","title":"Create a model","text":"A bunch of models are already writtne within the package. If str_model::String is the name of an implemented model, then load_model(str_model) creates a variable with name str_model.","category":"page"},{"location":"create_model.html","page":"Create a model","title":"Create a model","text":"load_model(\"poisson\")","category":"page"},{"location":"create_model.html","page":"Create a model","title":"Create a model","text":"Available models are listed below.","category":"page"},{"location":"create_model.html#Define-a-Chemical-Reaction-Network","page":"Create a model","title":"Define a Chemical Reaction Network","text":"","category":"section"},{"location":"create_model.html","page":"Create a model","title":"Create a model","text":"Let's consider the Chemical Reaction Network of the SIR model:","category":"page"},{"location":"create_model.html","page":"Create a model","title":"Create a model","text":"`` Infection: S + I \\xrightarrow{ki} 2I \\\nRecovery: I \\xrightarrow{kr} R ``","category":"page"},{"location":"create_model.html","page":"Create a model","title":"Create a model","text":"The macro @network_model creates easily a CTMC stored in a ContinuousTimeModel variable based on this formalism.","category":"page"},{"location":"create_model.html","page":"Create a model","title":"Create a model","text":"julia> easy_sir = @network_model begin\n       Infection: (S + I => 2I, ki*I*S)\n       Recovery: (I => R, kr*I)\n       end \"My awesome SIR\"\nMy_awesome_SIRModel <: ContinuousTimeModel model\n- variables :\n* I (index = 2 in state space)\n* R (index = 3 in state space)\n* S (index = 1 in state space)\n- parameters :\n* ki (index = 1 in parameter space)\n* kr (index = 2 in parameter space)\n- transitions : Infection,Recovery\n- observed variables :\n* S (index = 1 in observed state space, index = 1 in state space)\n* I (index = 2 in observed state space, index = 2 in state space)\n* R (index = 3 in observed state space, index = 3 in state space)\np = [0.0, 0.0]\nx0 = [0, 0, 0]\nt0 = 0.0\ntime bound = Inf","category":"page"},{"location":"create_model.html","page":"Create a model","title":"Create a model","text":"In the first reaction, ki*I*S is the reaction rate of the reaction Infection. This model is almost ready to use, we have to set the initial state and the parameters.","category":"page"},{"location":"create_model.html","page":"Create a model","title":"Create a model","text":"julia> set_param!(easy_sir, [0.0012, 0.05])\n       set_x0!(easy_sir, [95, 5, 0])\n       σ = simulate(easy_sir)\n       load_plots()\n       plot(σ)","category":"page"},{"location":"create_model.html","page":"Create a model","title":"Create a model","text":"(Image: Plot of a simulated SIR trajectory)","category":"page"},{"location":"create_model.html#Manually-(advanced)","page":"Create a model","title":"Manually (advanced)","text":"","category":"section"},{"location":"create_model.html","page":"Create a model","title":"Create a model","text":"This page is intented to advanced uses of the package, in order to use","category":"page"},{"location":"create_model.html#Based-on-an-existing-model","page":"Create a model","title":"Based on an existing model","text":"","category":"section"},{"location":"create_model.html#From-scratch","page":"Create a model","title":"From scratch","text":"","category":"section"},{"location":"create_model.html","page":"Create a model","title":"Create a model","text":"When the above cases don't fit your application one can create manually a ContinuousTimeModel. Let's take a look about the signature of the constructor method:","category":"page"},{"location":"create_model.html","page":"Create a model","title":"Create a model","text":"function ContinuousTimeModel(dim_state::Int, dim_params::Int, map_var_idx::Dict{VariableModel,Int}, \n                             map_param_idx::Dict{ParameterModel,Int}, transitions::Vector{<:Transition},\n                             p::Vector{Float64}, x0::Vector{Int}, t0::Float64, \n                             f!::Function, isabsorbing::Function; kwargs)","category":"page"},{"location":"create_model.html","page":"Create a model","title":"Create a model","text":"Let's construct an SIR model manually. First, one has to specify the dimensions of the state space and the parameter space.","category":"page"},{"location":"create_model.html","page":"Create a model","title":"Create a model","text":"dim_state_sir, dim_params_sir = 3, 2","category":"page"},{"location":"create_model.html","page":"Create a model","title":"Create a model","text":"map_var_idx is a dictionary that maps each model variable (represented by a Symbol) to an index in the state space.","category":"page"},{"location":"create_model.html","page":"Create a model","title":"Create a model","text":"map_var_idx_sir = Dict(:S => 1, :I => 2, :R => 3)","category":"page"},{"location":"create_model.html","page":"Create a model","title":"Create a model","text":"map_var_params is the equivalent of map_var_idx for parameters.","category":"page"},{"location":"create_model.html","page":"Create a model","title":"Create a model","text":"map_params_idx_sir = Dict(:ki => 1, :kr => 2)","category":"page"},{"location":"create_model.html","page":"Create a model","title":"Create a model","text":"transitions are the transitions/reactions of the model (vector of Symbol), p, x0 and t0 are respectively the parameters, the initial state and initial time of the model.","category":"page"},{"location":"create_model.html","page":"Create a model","title":"Create a model","text":"transitions_sir = [:Infection, :Recovery]\np_sir = [0.0012, 0.05]\nx0_sir = [95, 5, 0]\nt0_sir = 0.0","category":"page"},{"location":"create_model.html","page":"Create a model","title":"Create a model","text":"The two last arguments are functions, the first one, called f! must have the signature:","category":"page"},{"location":"create_model.html","page":"Create a model","title":"Create a model","text":"function f!(xnplus1::Vector{Int}, ptr_t::Vector{Float64}, ptr_tr::Vector{Transition},\n            xn::Vector{Int}, tn::Float64, p::Vector{Float64})","category":"page"},{"location":"create_model.html","page":"Create a model","title":"Create a model","text":"It should return nothing. xnplus1, ptr_t and ptr_tr are vectors where the next values are stored. ptr_t is of length 1 and stores the next time value (ptr_t[1] = tn + delta_t) whereas ptr_tr stores the name of the next transition/reaction (ptr_tr[1] = :Infection for example). This function is implemented in the package as:","category":"page"},{"location":"create_model.html","page":"Create a model","title":"Create a model","text":"@everywhere function sir_f!(xnplus1::Vector{Int}, l_t::Vector{Float64}, l_tr::Vector{Transition},\n                             xn::Vector{Int}, tn::Float64, p::Vector{Float64})\n    @inbounds a1 = p[1] * xn[1] * xn[2]\n    @inbounds a2 = p[2] * xn[2]\n    l_a = (a1, a2)\n    asum = sum(l_a)\n    if asum == 0.0\n        copyto!(xnplus1, xn)\n        return nothing\n    end\n    nu_1 = (-1, 1, 0)\n    nu_2 = (0, -1, 1)\n    l_nu = (nu_1, nu_2)\n    l_str_R = (:Infection, :Recovery)\n\n    u1 = rand()\n    u2 = rand()\n    tau = - log(u1) / asum\n    b_inf = 0.0\n    b_sup = a1\n    reaction = 0\n    for i = 1:2 \n        if b_inf < asum*u2 < b_sup\n            reaction = i\n            break\n        end\n        @inbounds b_inf += l_a[i]\n        @inbounds b_sup += l_a[i+1]\n    end\n \n    nu = l_nu[reaction]\n    for i = 1:3\n        @inbounds xnplus1[i] = xn[i]+nu[i]\n    end\n    @inbounds l_t[1] = tn + tau\n    @inbounds l_tr[1] = l_str_R[reaction]\nend","category":"page"},{"location":"create_model.html","page":"Create a model","title":"Create a model","text":"i The second function called isaborbing must have the signature:","category":"page"},{"location":"create_model.html","page":"Create a model","title":"Create a model","text":"isabsorbing(p::Vector{Float64}, xn::Vector{Int})","category":"page"},{"location":"create_model.html","page":"Create a model","title":"Create a model","text":"This function checks if the state xn is an absorbing state according to the model parametrised by p. It has to return true or false.","category":"page"},{"location":"create_model.html","page":"Create a model","title":"Create a model","text":"For a CTMC, a state is an absorbing state if the total exit rate is zero. In the case of the SIR model;","category":"page"},{"location":"create_model.html","page":"Create a model","title":"Create a model","text":"@everywhere sir_isabsorbing(p::Vector{Float64}, xn::Vector{Int}) = (p[1]*xn[1]*xn[2] + p[2]*xn[2]) === 0.0","category":"page"},{"location":"create_model.html","page":"Create a model","title":"Create a model","text":"Finally one sets the observed variables and the model can be created. The following lines creates a new type TryhardSIRModel <: ContinuousTimeModel, and the core of simulation.","category":"page"},{"location":"create_model.html","page":"Create a model","title":"Create a model","text":"g_sir = [:I]\n\n# Generates simulate method for the new model\n@everywhere @eval $(ABCRN.generate_code_model_type_def(:TryhardSIRModel))\n@everywhere @eval $(ABCRN.generate_code_model_type_constructor(:TryhardSIRModel))\n@everywhere @eval $(ABCRN.generate_code_simulation(:TryhardSIRModel, :sir_f!, :sir_isabsorbing))\n\ntryhard_sir = TryhardSIRModel(dim_state_sir, dim_params_sir, \n                              map_var_idx_sir, map_params_idx_sir, \n                              transitions_sir, p_sir, x0_sir, t0_sir, \n                              :sir_f!, :sir_isabsorbing; g = g_sir)\nσ = simulate(tryhard_sir)","category":"page"},{"location":"create_model.html#List-of-pre-written-models","page":"Create a model","title":"List of pre-written models","text":"","category":"section"},{"location":"create_model.html","page":"Create a model","title":"Create a model","text":"load_model(\"poisson\"): Poisson process\nload_model(\"ER\"): Michaelis-Menten kinetics (Enzymatic Reactions)\nload_model(\"SIR\"): Susceptible-Infected-Removed\nload_model(\"doping_3way_oscillator\"): Three-way oscillator with doping reactions\nload_model(\"repressilator\"): A repressilator model","category":"page"},{"location":"starting.html#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"starting.html#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"starting.html","page":"Getting Started","title":"Getting Started","text":"Launch Julia's REPL (for example by entering julia in your shell)\nEnter Pkg's REPL by typing ]\nEnter\npkg> add https://gitlab-research.centralesupelec.fr/2017bentrioum/markovprocesses.jl/","category":"page"},{"location":"starting.html#Context-Mathematical-framework","page":"Getting Started","title":"Context - Mathematical framework","text":"","category":"section"},{"location":"starting.html","page":"Getting Started","title":"Getting Started","text":"In this package, we are focused on Continuous-Time Markov Chains (CTMC, also called Markov jump processes), that can be described by Chemical Reaction Networks. The future state only depends on the current state. It is defined by two properties:","category":"page"},{"location":"starting.html","page":"Getting Started","title":"Getting Started","text":"forall t s in mathbbR_geq 0 mathbbP(S_t  S_v v in 0s) = mathbbP(S_t S_s) (Memoryless/Markov property)\nforall tv in mathbbR_geq 0 t  v mathbbP(S_t  S_v) = mathbbP(S_t-v  S_0) (Time-homogeneity).","category":"page"},{"location":"starting.html","page":"Getting Started","title":"Getting Started","text":"A Chemical Reaction Network (CRN) is a formalism that describes biological phenomena. An example is the Susceptible-Infected-Removed model (SIR):","category":"page"},{"location":"starting.html","page":"Getting Started","title":"Getting Started","text":"R_1 S + I xrightarrowk_i 2I R_2 I xrightarrowk_r R","category":"page"},{"location":"starting.html","page":"Getting Started","title":"Getting Started","text":"This CRN has two reactions that models two phenomena: infection (R_1) or immunisation (R_2). Each reaction is parametrized by a kinetic rate (k_i or k_r). The stochastic dynamics of a CRN are described by CTMCs.","category":"page"},{"location":"starting.html#Models","page":"Getting Started","title":"Models","text":"","category":"section"},{"location":"starting.html","page":"Getting Started","title":"Getting Started","text":"In the package, models are objects and their types all derived from the abstract type Model. Let's load the SIR model, which is pre-written within the package.","category":"page"},{"location":"starting.html","page":"Getting Started","title":"Getting Started","text":"julia> load_model(\"SIR\")\ncreate_SIR (generic function with 1 method)\n\njulia> println(SIR)\nSIRModel <: ContinuousTimeModel model\n- variables :\n* I (index = 2 in state space)\n* R (index = 3 in state space)\n* S (index = 1 in state space)\n- parameters :\n* ki (index = 1 in parameter space)\n* kr (index = 2 in parameter space)\n- transitions : R1,R2\n- observed variables :\n* I (index = 1 in observed state space, index = 2 in state space)\np = [0.0012, 0.05]\nx0 = [95, 5, 0]\nt0 = 0.0\ntime bound = Inf","category":"page"},{"location":"starting.html","page":"Getting Started","title":"Getting Started","text":"load_model has created a variable called SIR, which contains all the information for simulating the SIR model described above. It also contains a parameter vector and an initial point.","category":"page"},{"location":"starting.html","page":"Getting Started","title":"Getting Started","text":"julia> @show SIR.p \n       @show SIR.x0\nSIR.p = [0.0012, 0.05]\nSIR.x0 = [95, 5, 0]","category":"page"},{"location":"starting.html","page":"Getting Started","title":"Getting Started","text":"You can change the parameters or the initial state with the functions set_param! and set_x0!.","category":"page"},{"location":"starting.html","page":"Getting Started","title":"Getting Started","text":"julia> set_param!(SIR, :ki, 0.015)\njulia> @show SIR.p\nSIR.p = [0.015, 0.05]\n\njulia> set_param!(SIR, [0.02, 0.07])\njulia> @show SIR.p\nSIR.p = [0.02, 0.07]\n\njulia> set_x0!(SIR, :S, 93)\njulia> @show SIR.x0\nSIR.x0 = [93, 5, 0]","category":"page"},{"location":"starting.html#Trajectories","page":"Getting Started","title":"Trajectories","text":"","category":"section"},{"location":"starting.html","page":"Getting Started","title":"Getting Started","text":"The simulation of the model is done by the function simulate.","category":"page"},{"location":"starting.html","page":"Getting Started","title":"Getting Started","text":"julia> σ = simulate(SIR)","category":"page"},{"location":"starting.html","page":"Getting Started","title":"Getting Started","text":"simulate returns a trajectory, which type is derived from AbstractTrajectory. It can be either an object of type Trajectory for models ::ContinuousTimeModel or SynchronizedTrajectory for models that includes an automaton (but this is the subject of another section). It is easy to access the values of a trajectory.","category":"page"},{"location":"starting.html","page":"Getting Started","title":"Getting Started","text":"julia> @show σ[3] # the third state of the trajectory\n       @show length_states(σ) # number of states\n       @show σ[:I, 4] # Fourth value of the variable I\n       @show σ.I[4] # Fourth value of the variable I\n       @show get_state_from_time(σ, 2.3)\n\nσ[3] = [7]\nlength_states(σ) = 196\nσ[:I, 4] = 8\nσ.I[4] = 8\nget_state_from_time(σ, 2.3) = [79]","category":"page"},{"location":"starting.html","page":"Getting Started","title":"Getting Started","text":"The SIR object includes an observation model symbolized by the vector SIR.g. Even if the variables of the model are [:S, :I, :R], only I will be observed.","category":"page"},{"location":"starting.html","page":"Getting Started","title":"Getting Started","text":"julia> @show SIR.map_var_idx\n       @show SIR.g\n       @show size(σ.values), length(σ[:I]) # Only one column which corresponds to the I variable\nSIR.map_var_idx = Dict(:I => 2,:R => 3,:S => 1)\nSIR.g = [:I]\n(size(σ.values), length(σ[:I])) = ((1,), 196)","category":"page"},{"location":"starting.html","page":"Getting Started","title":"Getting Started","text":"The SIR model is by default unbounded, i.e. each trajectory is simulated until it reaches an absorbing state.","category":"page"},{"location":"starting.html","page":"Getting Started","title":"Getting Started","text":"julia> @show isbounded(SIR)\n       @show isbounded(σ)\nisbounded(SIR) = false\nisbounded(σ) = false","category":"page"},{"location":"starting.html","page":"Getting Started","title":"Getting Started","text":"We can bound the SIR's trajectories until time 120 by running set_time_bound!(SIR, 120.0).","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"CurrentModule = ABCRN","category":"page"},{"location":"index.html#ABCRN.jl","page":"Home","title":"ABCRN.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"A package for simulation, verification and parameter estimation of Chemical Reaction Networks.","category":"page"},{"location":"index.html#Package-features","page":"Home","title":"Package features","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"A core of simulation for Continuous-Time Markov Chains (CTMC) defined by Chemical Reaction Networks (CRN),\nA simple interface for Biochemical Networks / Stochastic Petri Nets,\nSynchronized simulation with Linear Hybrid Automata,\nApproximate Bayesian Computation, a likelihood-free inference method,\nAutomaton-ABC: a statistical method for verification of parametric CTMCs.","category":"page"},{"location":"api/plots.html#Plots-related-methods","page":"Plots","title":"Plots related methods","text":"","category":"section"},{"location":"api/plots.html","page":"Plots","title":"Plots","text":"Modules = [ABCRN]\nPages   = [\"src/plots.jl\"]","category":"page"}]
}
